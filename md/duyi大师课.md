# 事件循环机制

**进程：** 可以简单的将运行内存理解为进程

**线程：** 每个进程中执行代码的部分为线程

**浏览器中的进程：** 

- 浏览器进程：

  主要负责界面显示、用户交互、子进程管理

- 网络进程

  负责加载网络资源

- 渲染进程

  渲染进程启动后，会开启一个渲染主进程，负责执行`HTML`、`CSS3`、`JS `代码

## 浏览器如何调度任务

问题：

- 我正在执行一个` JS` 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗?
- 我正在执行一个` JS `函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗?
- 浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢?

解决：**排队**

![消息队列](./消息队列.png)

1. 在最开始的时候，渲染主线程会进入一个无限循环
2. 在每一次的循环中会检查消息队列中是否有任务，如果有就取出第一个任务执行，执行完毕后进入下一次循环，若没有，则进入休眠
3. 所有的线程都可以随时向消息队列添加任务。新任务添加到末尾。

称为事件循环`event loop` (消息循环`message loop`)

## 面试题

> 阐述一下JS的事件循环

参考答案:
事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。在 chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列未尾即可。过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。
根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行

> js中的计时器能做到精确计时吗

不行，

1. 计算机的时间利用的是寄存器实现的，无法做到原子钟的精确计时
2. 操作系统的计时函数本身就会有一点偏差，同时js的计时器最终调用的就是操作系统的函数，所以也会有偏差
3. 按照`W3C`的标准，浏览器实现计时器的时候，如果嵌套超过 5 层，就会带有最少 4 毫秒的延迟，在计时时间少于 4 毫秒的时候也带来了偏差
4. 受事件循环的影响，计时器的回调函数只能在主线程空闲的时候运行，因此当主线程中任务没结束并且计时已完成的时候，并不会立即执行计时器的回调函数，也会带来偏差

## 总结

**单线程是异步产生的原因**

**事件循环是异步的实现方式**