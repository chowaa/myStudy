## 谈谈路由

路由本质是一个组件的映射关系，是路径和页面的映射关系， 路由常用于开发SPA单页面应用，在我的理解中， 想使用好路由，主要是把握以下五个点， 路由跳转， 路由传参，路由守卫，路由懒加载，路由缓存

路由跳转有编程式跳转和声明式跳转两种方式，其中声明式跳转式跳转是使用router-link标签中的to属性去设置跳转路径。 to属性值可以写成路径字符串，也可以写成对象的形式，但要注意的是，如果是params参数，必须给路由配置name指定别名来指定path，而不是路径字符创， 对于query参数却没有这个限制

编程式导航是使用的router上的push或者replace进行跳转，但值得注意的是，在vue3.0后使用编程式的路由跳转，还需要额外传入两个参数即成功或者失败的回调函数，如果不传入页面会报错， 原因是因为引入了promise的语法， 一般我的解决方案是修正Vue原型上的push方法和replace方法（如没有指定回调函数，需要调用原本的push()的catch（）去处理错误的promise，如果传入了回调函数，本身就没有问题， 直接调用原本的push（）就可以。）

路由传参一般会使用query和params参数，params参数可以在跳转时直接拼串在路径中，但值得注意的是 ，在注册路由的时候，需要用到变量名占位，如果不使用的话， 页面刷新会丢失参数，使用query参数在注册路由时不需要占位，传递的时候可以直接使用对象的形式传递参数。

由于普通的写法使的页面中的vue和vue-router的耦合性高所以可以在注册路由的时候使用props解耦,将路由的参数映射到组件对象的props属性上,降低代码耦合性.props可以设置为布尔值,对象,函数.如果是布尔值,只能映射params参数,如果是对象,可以按原样映射属性,但不能映射路由信息.项目中我使用的是函数模式,它的参数就是route,可以将所需要的的路由信息也映射到props上.

路由守卫我一般是会用在权限配置上， 比如之前的项目需要根据登录状态去判断是否可以进入某些特定页面，此时我就是调用的路由守卫中的beforeEnter函数来判断token和用户信息是否存在，存在才可以跳转，不在得去登录页面先进行登录才可以跳转 ，除此之外还有路由独享守卫， 前置守卫，后置守卫等，以及组件内的守卫。

在性能优化和提升用户体验度方面，路由使用的组件我们会使用import函数进行路由懒加载，使用的时候才加载所需组件，优化性能，减少首屏打开的白屏事件， 也会使用keep-alive 标签来缓存路由组件，比如两个tab切换，缓存好路由组件，而不再需要进行重新加载

## 编程式导航跳转到当前路由路径，参数不变会报错

上一个项目没有遇见过这个问题，后面一个项目，19。8月开始后开始有个问题，而且声明式跳转没有这个问题， 只有编程式跳转有，当时也翻阅了很多官网的资料，是在vuerouter的issnes里找到了官方的推荐的解决方法。出现该问题的原因是因为，vue-router在3.0后引入了push（）的promise的语法，如果没有通过回调参数

指定回调就返回一个promise来指定成功/失败的回调，而且内部会判断如果要跳转的路径和参数都没有变化，会抛出一个失败的promise。

解决方法也有几个，比较一劳永逸的方法是重写Vue-router原型上的方法，如过没有指定回调函数，需要调用原本的push()的catch（）去处理错误的promise，如果传入了回调函数，本身就没有问题， 直接调用原本的push（）就可以。

还有一个是每次push的时候指定回调函数或catch错误， 这个比较繁琐。

## 项目中使用轮播图插件，切换组件后轮播图失效问题

当时的项目是做前台的评论多图展示， 使用到了swiper的滑块效果， 点击切换其他的组件，再回到原来的，轮播图会失效，。后来用debug排错，发现是轮播图写在了循坏里面， 而绑定轮播图使用的refs标签， 导致了refs重复使用，轮播图失效，后来解决办法是抽取轮播图为公共组件，并且传入一个动态的class值确保每个轮播图都是不一样的class

## 分类列表

功能：移入列表显示三级列表，并且有高亮显示

使用技术点: 防抖节流

解决: 采用了事件委托的事件冒泡原理， 将原来绑定个几百个li的函数绑定给父元素，其次，使用了函数的防抖和节流， 在这个功能里主要是用了函数的节流利用settimeout定时器分段执行的原理，让快速移入的时候不会每一个都触发回调函数，而是间隔200毫秒触发一个回调函数，节约内存，提高性能，而且也不会减低用户体验

### 防抖节流

节流： 是在固定的时间内触发事件，每几秒触发一次， 使用场景： 购物车抢购， dom拖拽事件

防抖： 频繁触发，只执行最后一次， 几秒内只执行一次，使用场景： 输入框输入东西联想

## 搜索列表

功能效果： 点击分类和关键字（keyword）搜索条件，显示对应的tag标签

解决：根据分类和关键字进行搜索， 主要是监视路由的变化，判断路由参数内部是否存在categoryName和keyword存在就显示，但是点击删除搜索条件的时候会有路径不变的bug，此时我采取的是手动去push跳转到对应参数的新路径。

keyword删除的时候，输入框没有同步删除的bug，这是采用的是vue全局时间总线， 删除关键字后通知header组件。触发$emit header组件的回调函数

## 自动登录逻辑

登录会携带用户的token存在localstoreage里，token主要是在请求拦截器里携带的。 用户访问网站时会先判断token是否存在，如果存在就发请求获取用户信息， 将用户信息存在localstorage里，如果不存在那么让其先去登录页面，先登录后返回之前的页面， 这里也会用到路由的redirect,用来跳转到用户来登录页面前的页面，增加用户体验

## spu sku 属性管理 品牌管理

## lodash  deepclone    防抖节流  

```
在后台项目过程中遇见的问题，是关于深拷贝和浅拷贝的问题。 该功能主要是对已有的属性值进行展示并且支持修改，最开始是以直接赋值的形式来操作的 发现无法修改数组中对象的值，因为该方法是浅拷贝，浅拷贝的时候，不同对象拷贝内部数组还是同一个数组，也就是说两个对象内部属性值的数组是同一个地址 。只能后来才采取的的lodash中的deepclone来进行深度克隆， 这样才可以展示并且修改数组中对象的值。。
```

## 数据整理 与想要的数据不符

## 防抖节流

函数防抖的应用场景

连续的事件，只需触发一次回调的场景有：

- 搜索框搜索输入。只需用户最后一次输入完，再发送请求
- 手机号、邮箱验证输入检测
- 窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。

函数节流的应用场景

间隔一段时间执行一次回调的场景有：

- 滚动加载，加载更多或滚到底部监听
- 谷歌搜索框，搜索联想功能
- 高频点击提交，表单重复提交

## 只读模式和修改模式的切换 

​	项目功能效果是做属性值的只读和修改模式的切换， 用到的技术是nexttick和$set 两种技术， 

$set用来给响应式对象设置响应式属性， 使其也具有响应式的，后面也可以使用点语法，其次数据修改的很快，但是页面更新的较慢， 而我们的项目是需要根据更新后的页面去操作的，此时必然用nextTick，nextTick的作用是等待页面最近一次更新完成之后，执行回调

## 项目的模板是 vue-element-admin

## 校验规则 表单

后台项目使用element-ui的插件库，会使用到elemen-ui自带的表单验证的规则进行校验， 但其实在项目过程中也会有其他的前台项目的登录注册页面会使用到验证， 也有自己手写过正则验证， 但更多的是使用vue的插件库vee-validate来做表单验证

## element-ui遇见的问题

按需引入messagebox 会报错， 需要用一个变量先接

按需引入的时候propComfirm删除弹框背景会变透明， 样式没了  原因： popover 没引入

做前台项目的时候dailog弹窗窗口会抖动，原因是有滚动条的存在， 给body加一个margin-right：19px的就行

element里的Scrollbar 必须单独import引入，不然不会生效

### element-ui按需引入打包的相关问题

### 问题1

- MessageBox使用时会提示错误: _MessageBox is not define

- https://github.com/ElementUI/babel-plugin-component/issues/31

- 解决

  ```javascript
  const msgbox = MessageBox // 将MessageBox保存给另一个变量
  const { alert, confirm, prompt } = msgbox
  ```

- 原因:  具体原因不详, 应该还是element-ui按需打包时出了问题

- 面试话术: 我在eleement-ui的issues和百度找到了此解决办法, 但没有找到具体的原因, 不知道咱们公司有没有遇到这样的问题

### 问题2

- 对Scrollbar进行引入: 不能通过element-ui引入, 只能明确指定单独引入
- 错误写法: import {Scrollbar} from 'element-ui' // 不能这样引入
- 正确写法: import Scrollbar from 'element-ui/lib/scrollbar' // 必须单独引入
- 原因: scrollbar是隐藏的组件, 没有像其它组件那样暴露出来

### 问题3

- PopConfirm的背景颜色从白色变为了透明色
- 原因: 组件内部用到了另一个组件PopOver, 白色背景的样式是定义在PopOver的对应的css文件中,由于我们没有直接使用PopOver, 所以没有显示的import引入, 那它对应的css就不会自动被打包

- 解决: import引入PopOv

## 权限设置  菜单权限 

全局前置守卫  动态添加路由

![image-20201123211417879](C:\Users\吃货小船\AppData\Roaming\Typora\typora-user-images\image-20201123211417879.png)

关键技术： 全局前置守卫 动态添加路由

流程： 先判断是否token，如果没有token，判断请求路径是否是白名单路由，是直接放行，不是强制跳转到login页面 ，如果有token，并且请求的是login页面，直接跳转到跟路由， 如果没有登录，那去往登录页面， 请求用户相关数据信息， 如果请求成功将用户数据保存在vuex中， 根据路由权限数据动态生成路由权限的数组， 将所有的权限路由和匹配任意路由的动态路由添加到router中，如果请求失败了， 删除cookie中的token， 删除vuex中的用户相关信息， 强制跳转到登录页面。

按钮权限主要是根据添加用户的时候添加的角色信息 如admin， 管理员等。 后期获取用户信息的时候获取用户的权限按钮数组，用来判断是否显示按钮



## promise

介绍：promise是ES6新增的异步编程实现方案， 在以往的异步编程中， 经常需要在回调函数中嵌套回调，嵌套的层级较多就会形成回调地狱，不利于我们阅读， promise的出现，解决了回调地狱的问题， 因为promise可以在异步任务后面指定回调，而不需要在继续嵌套回调。所以promise的作用主要就是解决回调地狱的问题

在promise的执行函数中， 开启异步任务执行函数是同步执行的同步代码，执行函数返回的结果决定了then中1执行哪个回调， 而then函数的执行也会返回promise， 这样就可以使用链式调用， 代码的可阅读性强。

promise的状态分为三个， resolved，rejected ， pending状态，状态只能改变一次，then函数返回的promise对象的状态取决于then的返回结果， 如果抛出错误或返回失败为rejected的promise对象， 其他情况都为成功状态的promise。

promise可以使用简化写法，即then中全部只指定成功的回调函数，最后用catch来捕捉错误， 或者在外层使用try...catch来捕获错误

promise中终极消灭回调地狱的方案是async 和await，他是promise的语法糖，内部也是用then函数来实现，返回的也是一个promise。

我在项目中最常用到async和await的场景是使用promise来封装用于发送请求的函数，其中使用async和await，为了使我们的异步代码，更像同步的代码。因为如果promise没有一个成功的值传入，对await来说就算是失败了，下面的代码就不会执行了

promise和async /await 函数的关系主要是

- async/await是消灭异步回调的终极武器w'w'w'w'w
- 作用: 简化promise对象的使用, 不用再使用then/catch来指定回调函数
- 但和Promise并不互斥, 两者相辅相成
- 执行async函数, 返回promise对象
- await相当于promise的then
- try...catch可捕获异常, 相当于promise的catch

当然promise也会一些其他使用的方法 比如，Promise.resolve(),Promise.reject()快速返回一个成功或者失败状态的promise对象，promise.all（）主要是开启多个任务， 当所有的任务都成功后才会返回成功的promise，否则就是失败的promise。

## ajax

ajax就是异步的js和xml,它本质也是一种http请求,，ajax主要用于不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。

### ajax的响应状态码有4个，

 2XX: 表示成功处理请求, 3XX: 需要重定向， 浏览器直接跳转, 4XX: 表示客户端请求错误,

5XX表示服务器错误， 常见的状态吗都有： 200  请求成功， 304 ，重定向到缓存， 404 找不到页面， 500服务器错误

### ajax和一般的http请求不同的是:

ajax是一种特别的http请求，

浏览器发送请求，只有XHR或fetch发出的才是ajax请求, 其它所有的都是非ajax请求, 但对于服务端来说没有任何区别，

浏览器接收到响应时候： 

一般http请求回更新/刷新页面

ajax请求，浏览器不会对界面进行任何更新操作， 只是调用监视的回调函数并传入响应相关数据

### ajax请求函数封装

```js
  function ajax(url){
      return new Promise((resolve,reject)=>{
        let xhr = new XMLHttpRequest()
        xhr.open('GET',url,true)
        xhr.send()
        xhr.onreadystatechange = function(){
          if(xhr.readyState !==4){
            return
          }
          if(xhr.status>=200 && xhr.status<=299){
              resolve(JSON.parse(xhr.responseText))
          }else
          reject( new Error(request.status))
        }
      })
    }
```

## 跨域

跨域一般是什么时候产生： 未满足同源策略就会产生跨域，同源策略就是指发送请求的地址和响应服务器地址的协议,域名,端口号都相同，在发送ajax和http请求的时候，服务器和当前网页不同源就不能发送，但是加载HTML中的img，url，script标签就不会受到限制。

那其实我们前端开发人员，日常工作经常会遇到解决跨域的问题， 我了解到的有三种解决跨域方式：

jsonp, CORS和proxy配置代理

jsonp主要是利用了<script>标签天然解决跨域的特性， 服务器返回处理请求的函数代码，再调用函数， 但是此方法目前不够实用， 因为只能处理get请求，而且请求都在后台处理，比较麻烦，一般都不使用。

cors，是在后台直接处理的直接允许跨域，主要是在设置响应头方面。

目前最主流的方式还是使用代理服务器来解决跨域问题，vue脚手架vue.config.js中DevServer中配置代理， 生产环境用nigix  来进行反向代理。 正向代理： 多个用户给我发请求，我转发给对应的请求地址， 反向代理是， 一个用户给我发请求， 我转发给多个请求地址。 比如我们平常的翻墙就是正向代理。 

在之前的项目中，我们主要是使用axios来发送ajax请求 ，axios是基于promise封装的异步ajax请求库，支持请求、响应拦截器， 和批量发送多个请求， 之前的项目， 就在请求和响应拦截器中配置了axios， 请求拦截器中开启了nprogress进度条， 也添加了很多功能，比如token的携带和用户临时id（uuid生成的），在响应拦截器中统一处理请求错误， 返回响应对象的data

## ES6

ES6是值从es6之后出的新特性， 其中包括 let,const ,箭头函数， promise， 类语法，三点运算符，解构赋值等，

let： 不允许重复声明， 块级作用域， 不存在变量提升， 不影响作用域链 

const 声明的时候必须赋值， 常量的名称不允许修改， 不能修改常量的值， 不允许重复定义， 块级作用域， 但是关于数组和对象的元素的修改， 可以修改里面的值

两者的应用场景： 声明引用（对象和数组，以及状态字符串）数据类型的，使用const, 声明其他的使用let

箭头函数是一个很实用的技术， 当箭头函数只有一行时候，且它就是返回值，可以省略函数花括号和返回值，参数只有一个的时候可以省略括号，最大的特点是箭头函数没有this， this是指上一层的作用域的this。

ES6新增的扩展运算符... 打包和拆包数组和对象非常方便，可快速实现对象和数组的浅拷贝，使用的时候就相当于把对象和数组摊开，用三个点代替。

新增了类语法， js类实际就是构造函数的语法糖，让构造函数的使用更加方便。他的特点是使用static添加静态属性。会变成类自己的属性， 使用赋值语句添加的属性， 会成为实例对象的属性，，直接添加的方法， 会自动成为原型上的方法。

还有两个比较重要东西，就是object.defineProperty 和proxy，reflect，object.defineProperty是实现vue2的数据代理的核心语法， 

proxy，reflect，是vue3的核心语法， 主要是用来做代理和反射的。

object.defineProperty是为对象添加属性值， 同时设置只读， 可枚举属性， 可以设置get和set两个属性， 其中get是读取属性的返回值，set 是监视属性值的变化。

## 移动端适配 

移动端适配主流的适配方案有三种： viewport适配， rem适配， vw适配

viewport适配主要是设置`布局视口宽度为设计稿宽度`，然后直接按照设计稿给宽高进行布局就行， 但是该方法的缺点也很明显， 不能使用完整的meta标签，会导致在有些安卓手机有兼容性问题， 而且图片会失真，宽度也会进行计算适配

但目前最主流的适配还是rem适配，实现的原理是编写样式时统一以rem为单位，通过js设置根字体大小，`（当前设备横向独立像素值*100 ）/设计稿宽度`。在不同设备上动态调整根字体大小。rem是相对于根元素（html)的字体大小， em是相对于父元素的字体大小。 

vm适配是按照百分比布局，会有兼容性问题 

vm和vh是两个相对单位

- 1vw = 等于布局视口宽度的1%
- 1vh = 等于布局视口高度的1%

物理像素：750px 、设备独立像素：375px、<span style='color:red'>css像素：375px</span>。

## webpack

### 五大核心

entry ： 入口起点， 只是webpack应该使用哪个模块作为构建模块依赖的开始

output：告诉webpack在哪里输出他所创建的 bundles，以及如何命名这些文件

loader： loader让webpack能够去处理那些非js文件

plugins： 插件 则可以用于执行范围更广的任务，例如：打包优化，压缩

mode: 模式，有生产模式production，和开发者模式development

### loader加载器

webpack本身只能识别js，json模块，其他模块一旦加载就会报错， loader就是帮助webpack识别她识别不了的模块的

常见的loader:  css  style  less sess  image url eslint bable  

分类分为：js文件 css文件  图片文件

css-loader 和style-loader的区别  ， css是打包成外联css, style是打包成内联css

### 常见的plugin 

loader的功能有限，想要做功能更强大的得交给plugin插件， 常见的插件有： 想在页面中自动引入打包生成的js/css ，压缩css，拷贝文件



出了loader之外的事情是plugin来做 比如：压缩 ，处理打包html 

html-webpack-plugin

 copy-

clean-

...

### 区别loader和plugin

webpack 只能打包js和json 需要有对应的loader来打包  为什么 是什么 怎么做 



### 区别module chunk 和bundle 

chunk 内存中生成的打包文件， 和本地的不是一一对应的关系  

### 区别打包站点hash化

### 项目中浏览器兼容如何做 

1. bable中的preset-env    es6---es5   

2. ```
    Promise无法进行转译，这个时候就需要在代码中引入babel-polyfill，让代码完美支持ES6+环境  babel-polifill体积86kb
   ```

3. 使用post-css 解决css兼容性

管理bug的工具  禅道

## vue3

是今年9月份vue发布的正式版， 我在十一假期的时候有了解一点， vue3支持vue2大多数新特性， ， 支持ts， 使用了proxy代替defineProperty实现数据响应式， 效率更高， 功能更强大了，设计了一个新的脚手架工具， vite,开发启动快了很多。

## vue3 和vue2的区别 

响应式： 

vue2   对象：通过defineproperty来对对象中属性值添加和修改属性值

数组: 通过重组数组更新数字一系列更新元素的方法来实现元素的数据劫持

会有问题： 对象直接新添加的属性或者删除已有属性，界面不会同步修改，直接通过数组的下标修改元素或者更新lenght, 界面不会有变化

vue3 :主要是通过proxy 代理，拦截对data任意操作，常用的三个：读取，修改删除属性值

通过refilect（反射） ：动态对被代理对象的任意属性进行特定的操作

解决了 vue2中的界面不会更新的问题

## Vue项目优化

主要分为vue代码层面的优化和webpack打包方面的优化，

vue层面是： v-for循环遍历，指定非index的唯一值key, 不同时使用v-if. 图片资源懒加载， 路由懒加载， 第三方插件按需引入，如： element-ui， 

大数组优化： 冻结响应式数据，`Object.freeze()`将数据冻结，对于data()或vuex中冻结的对象，vue不会做getter和setter的转换。因此对于一个不变的、大数据量的数组或Object数据来说

```
**`Object.freeze()`** 方法可以**冻结**一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。`freeze()` 返回和传入的参数相同的对象。
```

虚拟列表： 当数组处于非常长的列表时， 数据过多导致DOM元素同样多，导致卡顿， 界内一般是使用虚拟列表的手段，只渲染可看到的窗口的数据的DOM，

 虚拟列表的基本实现思路:  ==> 测试代码 vue/虚拟列表/index.html

​    用vue的for循环渲染列表，自己手动加一个滚动条，然后通过监听scroll，

​    算出应该显示到第几个，通过计算属性截取显示的数据

真实项目可以使用第三方插件:

​	[vue-virtual-scroll-list](

事件销毁：Vue 组件销毁时，实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。单独添加的监听事件是不会移除的，需要手动移除事件的监听，以免造成内存泄漏

webpac层面： 兼容性处理， 拆分打包与压缩，资源预加载， 文件名hash化， 代码tree shaking

基础的web技术层面的优化， 开启gzip,静态资源使用css/js/ing使用CDN引用 

## key的作用

 起什么作用 什么情况下效率低， 但页面效果没问题， 什么情况下页面会变化，如何解决问题呢？ 

key是虚拟DOM的标识， 在更新显示时候起作用，更新时key没有变， 会直接沿用之前的， 但如果key变了会销毁之前的真是DOM, 根据数据创建新的真实DOM ,如果将index作为key，添加删除和排序，会产生没有必要的真实 DOM更新，效率太低了 但是界面效果没有问题，如果有修改的情况出现， 比如有输入框的存在， 会产生错误的DOM更新， 界面都有问题。 但如果数据只是用来更新显示不修改， 用index是没有问题的。解决方案： 用唯一值 比如ID进行显示 

# react

传参 ： props 

区别函数组件类组件: 

函数组件：没有this. 没有state， 没有声明周期

类组件： 。。。

react为什么要用箭头函数： 因为不用this是undefined

路由的三个主要属性：

history: 包含路由跳转相关的方法

location： 

	1. pathname 请求的path
	2.  search：包含所有query参数的字符串   ？name =tom

match： params 参数的对象

路由传参的三种方式：

1. query 
2. params
3. state：



## BOM和DOM

我们都知道， javascript 有三部分构成，ECMAScript，DOM和BOM，根据宿主（浏览器）的不同，具体的表现形式也不尽相同，ie和其他的浏览器风格迥异。

\1. DOM 是 W3C 的标准； [所有浏览器公共遵守的标准]
\2. BOM 是 各个浏览器厂商根据 DOM
在各自浏览器上的实现;[表现为不同浏览器定义有差别,实现方式不同]
\3. window 是 BOM 对象，而非 js 对象；

DOM（文档对象模型）是 HTML 和 XML 的应用程序接口（API）。

BOM 主要处理浏览器窗口和框架，不过通常浏览器特定的 JavaScript 扩展都被看做 BOM 的一部分。这些扩展包括：

弹出新的浏览器窗口 移动、关闭浏览器窗口以及调整窗口大小 提供 Web 浏览器详细信息的定位对象 提供用户屏幕分辨率详细信息的屏幕对象 对 cookie 的支持 IE 扩展了 BOM，加入了 ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象

javacsript是通过访问BOM（Browser Object Model）对象来访问、控制、修改客户端(浏览器)，由于BOM的window包含了document，window对象的属性和方法是直接可以使用而且被感知的，因此可以直接使用window对象的document属性，通过document属性就可以访问、检索、修改XHTML文档内容与结构。因为document对象又是DOM（Document Object Model）模型的根节点。可以说，BOM包含了DOM(对象)，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。其中
DOM包含：window

Window对象包含属性：document、location、navigator、screen、history、frames Document根节点包含子节点：forms、location、anchors、images、links

从window.document已然可以看出，DOM的最根本的对象是BOM的window对象的子对象。

区别：DOM描述了处理网页内容的方法和接口，BOM描述了与浏览器进行交互的方法和接口。

# CSS

## C3新特性

C3新增了很多功能比如，animation， rgba, hsla ，C3选择器 ，比如关系，交集、并集、伪类选择器，

以往实现一些比较炫酷的效果都是js实现， 现在有了动画之后，做一些不太复杂的效果，性能更好，效果更佳，但是它也有一些局限性， 我们对动画过程性的控制性较弱， 不能暂停或在特定的时间添加回调等， 复杂的动画需要大量的CSS代码趋势线，比较简单的动画可以通过animation ， 复杂的还是要通过js实现

以及渐变，过渡， 2D3D动画功能， 背景图片可以通过设置背景图尺寸 background-size 来更好的使用精灵图，减少图片的加载次数， C3还引入了媒体查询，主要用于响应式， 让我们可以通过用户设备屏幕尺寸不同，显示不同的效果等

## BFC

在介绍BFC之前，需要先介绍下box, formatting context 的概念。 

box是css布局的基本单位， 直观点说， 一个页面就是由多个box组成的， 元素的类型由display属性决定box的类型，不同的box会参与不同的fromatting context（如何渲染文档的容器） 一般有block-level box，快级盒子， 参与BFC,另外一个是inline-level box 行内元素， 生成IFC。

BFC是什么？直译英文为快级格式化上下文， 是一个独立的渲染区域， 只有快级盒子参与，与inline没有关系，， 它规定了内部的block-level box 如何布局，，并且与这个区域外部毫不相关。 相当于开启了一块独立空间 

BFC的布局规则： 

1. 内部的box会垂直方向，一个接一个的摆放
2. 内部的box垂直方向的距离由margin决定， 属于同一个BFC的两个相邻的box的margin会发生重叠。
3. bfc的区域不会与float box（浮动盒子） 重叠
4. bfc就是页面上的一隔离的独立容器， 容器里面的子元素不会影响到外面的元素，只会管理自己内部的元素、

哪些元素会产生BFC?

1. 根元素HTML会默认开启
2. float属性不是none的情况 
3. position absolute 和fixed   相对定位不会开启 ！！
4. overflow不为 visited

## 盒模型

页面渲染时，dom，元素所采取的的布局模型， 可以通过box-sizing进行设置，根据宽高的区域可分为：

content-box （W3C标准盒模型）

border-box(IE盒模型)  怪异盒子

padding-box 

margin-box 浏览器未实现 

## 选择器优先级

！important > 行内样式 >#id  > .class > 标签 >* >继承> 默认

## 父元素塌陷解决办法

 通过增加伪元素 清除浮动

创建父级元素 BFC   overflow hidden

给父元素设置高度

## link 和 @import的区别

 link的功能比较多 可以定义 rss,定义rel等作用， 而 @import 只能用于加载CSS

 当解析到link时， 页面会同步加载所引入的css, 而 import是会等到页面加载完才被加载

import 必须要ie5 以上才能使用

link 可以使用js动态引入 但是@impor不可以

## CSS预处理器 Sass/Less/Postcss 

CSS预处理器的原理： 是将类CSS语言通过webpack编译成浏览器可读的css, 并赋予css更强大的功能， 比如：

嵌套， 变量 。循环语句，条件语句， 自动前缀， 单位转换，mixin复用

## 布局相关

flex  布局： 单独给某一个元素设置flex属性的时候可以提高当前flex的权重、、

圣杯布局：，圣杯布局中间有container大容器，包裹着左、中、右三个盒子，容器左右设置padding，给左右容器腾出位置， 左中右都浮动，中间设置 100%宽度，左边盒子margin-left- 100%，加相对定位， 右边盒子margin-left负自身宽度  

双飞翼布局：是中间的盒子用容器包裹起来， 包裹的容器设置padding留出左右位置，全部浮动， 左侧设置100%左外边距， 右边设置负自身宽度左外边距

## 定位相关

当元素设置定位后， 将元素设置到网页中的一个具体位置， 是一个脱离标准流的状态。

相对定位(占位定位)  ： 当元素设置相对定位后， 元素在标准流的位置还是存在的， 通过四个漂偏移量， 可以将元素设置在网页中的一个具体坐标位置

绝对定位： 是一个完全脱离标准流的状态， 默认参考点是当前的初始包含块即默认状态下的窗口第一屏

固定定位： 将元素设置到窗口的一个固定位置， 参考点永远是body

定位参考点：

1.绝对定位参考点是最近的开启（相对，绝对，固定）定位的祖先元素（父元素） 作为参考点的。如果没写会找body

## 浮动相关

当元素设置浮动后，是一个半脱离标准流的效果，

设置浮动会造成的问题： 

1. 由于浮动是脱离标准流的， 是飘起来的昨天， 在网页上不占位置， 并且会默认飘到当前父元素， 块元素的上面， 每个快元素都是一个单独的渲染区域BFC,此时后面的块元素会认为前面的浮动不占位置，所以会上来， 被浮动元素压在下面。 

  解决方案： 需要给浮动元素外层套一个DIV, 让这个块元素占位置， 此时就对后面的元素没有影响了， 。

2. 由于浮动不占位置， 此时给父元素（快元素）不设置固定高度， 父元素会认为没有内容占位置，此时高度是0， 会造成高度塌陷，

   解决办法：

   给父元素设置固定高度（不建议，因为这样不能实现高度自适应，不灵活）

   给父元素设置overflow：hidden

   额外标签法， 给毒元素的最后额外加一个子元素， 主要是为了设置 clear：both属性

   给父元素设置浮动

## 盒子居中

1. 经典 ： 父元素相对定位， 子元素绝对定位， 左上50%， 左上外边距为负的自身宽高一半，适用于居中元素宽高确定

2. 父元素相对定位，子元素绝对定位，左上各50%，子元素用位移： transition：translate -50% -50%、

3. 父元素相对定位， 子元素绝对定位， 上下左右都是0， margin auto

4. 弹性盒子。

5. 将父元素设置为下图： 子元素设置为行内块 

   ```
   display： table-cell
   text-algin: center;
   ,vertical-align:middle;
   ```

   

## 弹性盒子相关

弹性盒子是指父盒子和子盒子之间的关系， 父盒子是指弹性空间，弹性容器 子盒子是指弹性元素，弹性项。

默认方向是主轴是水平方向， 左边开始，右边结束。 



# HTML

## 标签语义化的意义

开发者更容易理解， 减少差异化， 方便团队开发和维护， 方便搜索爬虫， 方便其他设备解析， 比如读屏软件，盲人软件，移动设备等

## H5新特性

 新的语义化标签，比如footer， header， nav， section

表单增强， 新的表单控件， 比如： time， date， email  url等

新的api， 音频 video  audio  元素， 图形 （绘画  canvas元素）

新的api 本地存储， localstorage sessionStorage  localstorage 是没有时间限制的数据存储， sessionstorage 是随着浏览器窗口关闭， 数据删除。 新的API 实时通讯， 设备能力 

## 写结构注意点

尽可能少的使用没有语义的div，和span

 快级元素和内联元素的嵌套一定要符合web标准， 比如内联元素就不能 嵌套快级元素







# 简历介绍

## 学派网后台项目： 

域名： http://www.studypay.com/member/

学派网介绍 ： 大家网旗下的网站，专做工程，英语，财务，考研计算机的

学生管理后台系统，外包项目，开发时间: 3个月， 

使用框架： vue全家桶，vuex， vuerouter +element-UI,（table ，form， dailog）



## 批发户PC端

j域名：https://www.pfhoo.com/

介绍： 主要做跨境珠宝电商的。

开发时间： 5个月

使用框架: vue vueRouter，vuex,vee-validate
vue-lazyload,axios,nprogress,uuidjs,swiper lodash

模块： 

首页： swiper 轮播图，以及各组件

侧边栏导航： 绝对定位

搜索页面：点击复选框发请求  ， 综合的正序和倒叙排序，  搜索关键词和点击复选框发请求拿参数 添加标签 

详情页： swiper滑块，大图蒙版， 排他选择，

登录注册

# 顶尖文案PC端

首页： 轮播图   弹性盒子布局 空间包含元素展示 查看更多

文章详情页： 包括图片 video展示，评论展示

商品页面： 轮播图 弹性盒子布局





