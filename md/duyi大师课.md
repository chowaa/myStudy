# 事件循环机制

**进程：** 可以简单的将运行内存理解为进程

**线程：** 每个进程中执行代码的部分为线程

**浏览器中的进程：** 

- 浏览器进程：

  主要负责界面显示、用户交互、子进程管理

- 网络进程

  负责加载网络资源

- 渲染进程

  渲染进程启动后，会开启一个渲染主进程，负责执行`HTML`、`CSS3`、`JS `代码

## 浏览器如何调度任务

问题：

- 我正在执行一个` JS` 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗?
- 我正在执行一个` JS `函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗?
- 浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢?

解决：**排队**

![消息队列](./消息队列.png)

1. 在最开始的时候，渲染主线程会进入一个无限循环
2. 在每一次的循环中会检查消息队列中是否有任务，如果有就取出第一个任务执行，执行完毕后进入下一次循环，若没有，则进入休眠
3. 所有的线程都可以随时向消息队列添加任务。新任务添加到末尾。

称为事件循环`event loop` (消息循环`message loop`)

## 面试题

> 阐述一下JS的事件循环

参考答案:
事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。在 chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列未尾即可。过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。
根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行

> js中的计时器能做到精确计时吗

不行，

1. 计算机的时间利用的是寄存器实现的，无法做到原子钟的精确计时
2. 操作系统的计时函数本身就会有一点偏差，同时js的计时器最终调用的就是操作系统的函数，所以也会有偏差
3. 按照`W3C`的标准，浏览器实现计时器的时候，如果嵌套超过 5 层，就会带有最少 4 毫秒的延迟，在计时时间少于 4 毫秒的时候也带来了偏差
4. 受事件循环的影响，计时器的回调函数只能在主线程空闲的时候运行，因此当主线程中任务没结束并且计时已完成的时候，并不会立即执行计时器的回调函数，也会带来偏差

## 总结

**单线程是异步产生的原因**

**事件循环是异步的实现方式**

# 浏览器渲染原理

`render`：渲染，把`HTML`字符串渲染成像素信息

## 浏览器是如何渲染页面的？

当浏览器的网络线程收到`HTML`文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程

------

HTML字符串 → 解析HTML → 样式计算 → 布局 → 分层 → 绘制 → 分块 → 光栅化 → 画 → 像素信息

- 1、解析HTML--- `Parse HTML`

生成DOM树 `Document Object Model` 

![DOM](D:\Desktop\web\前端\md\DOM.png)

生成CSSOM树 `CSS Object Model` 

![CSSOM](D:\Desktop\web\前端\md\CSSOM.png)

HTML解析过程中遇到CSS代码时，浏览器会启动一个预解析器率先下载和解析CSS。`JS也是要预下载`

如果主线程解析到 `Link` 位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，而是继续解析后续的 HTML 。这是因为下载和解析 CSS 的工作是在与解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。

如果主线程解析到 `Script` 位置，会停止解析 HTML ，转而等待 JS 文件下载完毕，并将全局代码解析执行完成后，才能继续解析 HTML 。这是因为 JS 代码在执行过程中可能会修改当前 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTMl 解析的根本原因

- 2、样式计算 — Recalculate Style



















