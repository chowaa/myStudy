#### vue2和vue3

```
数据的绑定和劫持的使用方法不同（双向绑定的方法不同）
	Vue2使用：Object.defineProperty
	Vue3使用：new Proxy
vue2使用选项式api，vue3既能使用组合式api也能使用选项式api，
vue2中v-for优先级高于v-if，vue3相反
vue3移除filter过滤器
vue3支持pinia
vue3相对于vue2生命周期也做了一些更改
```

#### 原型和原型链

```
原型：任意一个构造函数都有一个prototype属性，prototype就是原型对象，存储的是对象的公用属性
原型链：先在对象的私有属性中查找，如果找到则返回该属性对应的值，如果没有找到，就会沿着__proto__属性到它的原型中查找，找到则返会对应的值，没找到，那么会沿着原型链向上查找，直到找到Object构造方法的原型为止，如果还没找到则返回undefined
```

#### B端和C端的定义

```
B端：通常为企业内部或商家使用的系统或平台。如：企业内部ERP管理系统、财务管理平台等。
C端：通常为消费者、个人终端用户使用的客户端。如：微信、淘宝、网易云音乐等。
```

#### 说说你对生命周期的理解

```
什么是生命周期：vue实例从创建到销毁的过程
生命周期钩子函数：在这个生命周期过程中，vue为我们提供了8个常用的钩子函数。

生命周期：
	总共分为8个阶段，创建前/后，载入前/后，更新前/后，销毁前/后。
beforeCreate：
	阶段，vue实例的挂载元素$el和数据对象data都为undefined，data和methods还未初始化。
created：
	阶段，数据对象data和methods已经初始化，但$el还没有，视图和实例还没有挂载。
beforeMount：
	阶段，vue实例的$el和数据对象data都已经初始化，但还是虚拟的dom节点，视图和实例还没有挂载。
mounted：
	阶段，模板已经编译好，虚拟dom渲染成真正的dom标签，数据已经渲染到页面，Vue实例已经创建完毕。
beforeUpdate：
	阶段当数据依赖改变时，对象data中的 数据已经更改（虚拟dom已经重新渲 染），但是还未开始渲染真正dom，页面中的值还是原来的。
updated：
	阶段data中的数据更新完毕，页面已经被重新渲染。
beforeDestroy：
	阶段实例还是可用的一般在这里做一些善后工作。（例如清除定时器、清除非指令绑定的事件等等。）。
destroyed：
	阶段Vue实例被销毁，观察者、子组件、事件监听被清除（页面数据不会消失，只是响应式无效了）。

应用场景：

一般会在created阶段做网络请求,在mounted阶段对第三方插件的初始化。
在beforeDestroy阶段进行清除定时器和一些事件的解绑
```

#### node.js的理解

node.js是一个运行环境

npm是Node 的包管理系统

```
npm安装命令 ： npm install
```

#### 获取节点名称

```
nodeName
```

#### js和jq创建DOM元素

```
js是createElement(‘div’) jq是$( )
```

#### 获取标签/dom节点

```
getElementById  querySelector
```

#### 数组去重的方法

```
数组去重的方法有很多，我常用的是indexOf和filter来实现的
var arr1 = arr.filter(( item,index) = {
    return  arr.indexOf(item) === index
    })
    
利用set和Array.from()
const result = Array.from(new Set(arr))
```

#### 数组的冒泡原理及其实现

```
原理：相邻的两项进行比较，如果前面的一项大于（小于）后面的项，则交换位置。直到最大（最小）数沉底为止。
实现：
var arr=[21,32,2,9,4];
     var arr = [32,1,34,6,4,4,8]
			for (var i = 0; i < arr.length; i++) {
				for (var j = i+1; j < arr.length; j++) {
					if(arr[i]>arr[j]){
						var num = arr[i]
						arr[i] = arr[j]
						arr[j] = num
					}
				}
			}
```

#### window.onload和$(document).ready()的区别 / js和jq中就绪函数的区别

```
window.onload和ready都是属于就绪函数、区别是window.onload只执行一次、ready会执行多次。

所以ready要比onload要先执行
```

#### this的指向

```
this代表的是当前对象，由于执行环境不同，所代表的对象也不同
  在dom0事件中this指向调用这个函数的对象
  在构造函数中this指向创建新的实例
  在箭头函数中this指向当前函数外离他最近的对象
  在call和apply中，this会指向第一个参数
```

#### 闭包

```
函数嵌套函数，内部函数可以访问外部函数的变量
优点：可以访问函数内部变量
缺点：数据不会被垃圾回收机制回收，数据一直存放，可能造成数据泄露
```

#### 深浅拷贝

```
深浅拷贝是针对引用类型数据来说的
浅拷贝：只复制拷贝的对象的一层，不复制拷贝对象的内存
深拷贝：完全复制拷贝对象，复制拷贝对象的内存
浅拷贝 for循环，while循环 map，filter，
深拷贝可以使用递归，JSON序列化()和扩展运算符
```

#### 浅拷贝和赋值的区别

```
浅拷贝：浅拷贝会创建一个对象，再去遍历原始对象，如果原对象的属性值是基础类型，那么就拷贝基础类型，如果是引用类型，则拷贝的是指针
赋值：将一个对象赋值给一个新的对象的时候，赋的其实是该对象在栈中的地址，而不是堆中的数据。 也就是一个对象的改变就会改变另外一个对象
```

#### 浅拷贝

```
for循环实现浅拷贝
numbers = [1, 2, 3];
numbersCopy = [];
for (i = 0; i < numbers.length; i++) {
  numbersCopy[i] = numbers[i];
}
```

#### 递归实现深拷贝

```
function beBrave(data) {
            let obj = Array.isArray(data) ? [] : {}
            if(Array.isArray(data)){
              data.forEach(item=>{
                obj.push(beBrave(item))
              })
            }else if(typeof data === 'object'){
              for(key in data){
                obj[key] = beBrave(data[key])
              }
            }else if(typeof data === 'number' || 'boolean' || 'string') return data
            return obj
          }


function beBrave(data) {
  if (Array.isArray(data)) {
    return data.map((item) => beBrave(item));
  } else if (typeof data === "object") {
    return Object.fromEntries(
      Object.entries(data).map(([key, value]) => [key, beBrave(value)])
    );
  }
  return data;
}
```

#### 防抖和节流

```
防抖： 执行最后一次
节流：	只执行一次

节流在规定时间内执行一次 应用场景：
防抖在多次执行只执行最后一次  应用场景：登录或提交数据，防止多次请求

防抖等于回城，截流等于技能
```

#### 响应式布局的实现 / 移动端的适配

响应式布局是指在不同设备尺寸下，网页能够自适应地进行布局和显示。实现响应式布局主要有以下几种方法：

使用CSS媒体查询：利用CSS媒体查询来根据不同设备尺寸应用不同的CSS样式，使网页能够自适应地进行布局和显示。

```
/* 应用于小于等于768px宽度的设备 */
@media screen and (max-width: 768px) {
  .container {
    width: 100%;
  }
}

/* 应用于大于768px宽度的设备 */
@media screen and (min-width: 769px) {
  .container {
    width: 768px;
  }
}
```

使用弹性布局（Flexbox）：使用Flexbox可以方便地实现网页元素在不同设备尺寸下的自适应布局，可以通过设置元素的flex属性来控制元素的大小和位置。

```
.container {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
}

.item {
  flex: 1;
}
```

#### sass和less的作用和区别

```
Sass和Less的主要功能和作用如下：

1. 变量：可以定义变量来存储颜色、字体、尺寸等属性，方便在整个样式表中重复使用。
2. 嵌套：可以将选择器嵌套在父选择器内部，降低代码层次结构，提高可读性。
3. 混合（Mixin）：可以创建一组CSS属性集合，然后在其他样式中引用，类似于函数调用。
4. 继承：可以使用@extend指令扩展一个选择器的样式。

Sass和Less的区别主要有以下几点：

1. 语法不同：Sass使用缩进式语法，而Less使用类似CSS的语法。
2. 变量声明方式不同：Sass使用$符号声明变量，而Less使用@符号声明变量。
3. 混合方式不同：Sass使用@include指令来调用混合，而Less使用.mixin()方法来定义和调用混合。
```

#### js创建实例的方法

```
new一个实例
```

#### js预解析

```
在当前作用域中，JavaScript代码执行之前，浏览器首先会默认的把所有带var和function声明的变量进行提前的声明或者定义。
```

#### 事件流

```
事件流分为三个阶段：事件捕获、事件目标、事件冒泡
```

#### 事件捕获

```
父盒子可以捕获到子盒子的事件
```

#### 阻止事件冒泡

```
event.stopPropagation()
```

#### es6新增

```
新增两个基本数据类型 （Symbol（表示一个独一无二的值） 和 BigInt（表示一个任意大的数））和五个复杂类型 Set Map WeakSet WeakMap TypedArray
新增声明方式 const let
新增数组和对象的方法
promise
扩展运算符
模板字符串
箭头函数
class类 （实际运用不多）
```

#### const

```
定义的基础类型不能修改，引用类型可以
```



#### es6新增数据类型

```
Symbol 是一种在ES6 中新添加的数据类型，本质上是一种唯一标识符，可用作对象的唯一属性名，这样其他人就不会改写或覆盖你设置的属性值。
BigInt 表示一个任意大的整数
```

#### es6新增数组方法

```
find();查找数组某个元素
findIndex();查找某个元素的索引值
some();数组中是否有元素符合条件
every();数组中是否所有的元素都符合条件
```

#### es6新增对象方法

```
Object.assign(); 复制一个对象
Object.keys(); 得到一个对象的所有属性；
Object.values(); 得到一个对象的所有可枚举属性值；
Object.entries(); 得到一个对象的键值对数组；
Object.fromEntries(); entries的逆操作；
```

#### Set的用法

```
Set 与数组类似， Set 集合中的元素不重复
```

#### Map的用法

```
map是对象的一个方法，循环数组返回一个处理过的新数组
```

####  set和map

```
1. Map是键值对，Set是值的集合
2. Map可以通过get方法获取值，而set不能，因为它只有值；
3. 都能通过迭代器进行for...of遍历
4. Set的值是唯一的可以做数组去重，Map由于没有格式限制，可以做数据存储
```

#### 在箭头函数中拿到参数

```
使用rest
```

#### es6的类里添加一些方法

```
function MyClass(name,age){
  this.name = name;
  this.age = age;
}
var cls1 = new MyClass("lily",18);
alert(cls1.name);
// 添加方法
MyClass.prototype = {
    toString:function(){
        //
    },
    sayHellow:function(){
        //
    }
};
```

#### promise的理解

```
Promise是一种异步编程的解决方案，它可以用来处理异步操作，并在操作完成后返回结果。Promise有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。两个参数resolve和reject，在promise对象中，当异步操作执行成功时，会返回一个resolve状态的结果，而当异步操作执行失败时，则会返回一个reject状态的结果。通过链式调用.then()方法，我们可以对promise返回的结果进行处理，以达到我们想要的效果。使用promise可以避免回调函数地狱，提高代码的可读性和可维护性。
```

#### promise中原型的方法

```
then
catch
finally
```

#### promise中的静态方法

```
promise.all  所有的都成功时再执行.then
promise.race 只要有一个执行成功回调就会执行.then
Promise.resolve
Promise.reject
Promise.allSettled
Promise.any
```

#### import和require的区别

```
导入require 导出 exports/module.exports 是 CommonJS 的标准，通常适用范围如 Node.js

import/export 是S6的标准，通常适用范围如 React
require 是赋值过程并且是运行时才执行，也就是同步加载
require 可以理解为一个全局方法，因为它是一个方法所以意味着可以在任何地方执行。
import 是解构过程并且是编译时执行，理解为异步加载
import 会提升到整个模块的头部，具有置顶性，但是建议写在文件的顶部。
```

#### key的作用

```
vue中key给每个元素做唯一标识，通过key可以提高虚拟dom的渲染速度
```

#### vuex

```
Vuex是Vue.js的状态管理模式，用于管理应用程序的状态(state)。Vuex包含了一个全局状态树，用于存储应用程序的状态信息，同时提供了一些方法来修改状态树中的状态。

Vuex的核心概念包括：State、Getter、Mutation、Action和Module。

1. State：表示应用程序的状态信息，通常是一个对象，包含了多个属性，每个属性代表一个状态。Vuex的状态是响应式的，当状态发生变化时，所有引用该状态的组件都会重新渲染。
2. Getter：用于获取状态信息，类似于计算属性，可以对状态进行计算和转换。
3. Mutation：用于修改状态信息，通常是同步的，只能通过提交Mutation来修改状态，Mutation中的方法必须是同步的，否则状态管理会出现问题。
4. Action：用于处理异步操作，通常是通过提交Action来触发异步操作，Action中的方法可以是异步的，可以通过调用Mutation来修改状态。
5. Module：用于将应用程序的状态信息分成多个模块，每个模块包含自己的State、Getter、Mutation和Action。

Vuex的优势在于它可以集中管理应用程序的状态信息，避免了组件之间的状态传递和管理问题，同时也提供了一些方法来处理状态的变化和异步操作，可以有效提高应用程序的可维护性和可扩展性。
```

####  MVVM和MVC的区别

```
MVC和MVVM的区别其实并不大。都是一种设计思想。
主要就是MVC中Controller演变成MVVM中的viewModel。
MVVM主要解决了MVC中大量的DOM操作使页面渲染性能降低，加载速度变慢，影响用户体验。
当和Model频繁发生变化，开发者需要主动更新到View。
```

#### 切换git分支

```
git checkout '分支'
```

#### git合并代码的流程

```
首先，将目标分支切换到最新版本，使用以下命令：git checkout target_branc
然后，将源分支合并到目标分支，使用以下命令：git merge source_branch
如果合并过程中出现了冲突，需要手动解决冲突。可以使用以下命令查看冲突文件：git status，然后打开冲突文件进行修改。
解决冲突后，使用以下命令将修改后的文件加入暂存区：git add conflict_file
最后，使用以下命令提交合并结果：git commit -m "merge message"
如果需要将合并结果推送到远程仓库，使用以下命令：git push
注意：在合并代码之前，最好先从远程仓库拉取最新的代码，以避免冲突和代码丢失。可以使用以下命令：git pull
```

#### git相关命令

```
git clone  	地址				     克隆项目
git checkout '分支'				 切换分支
git reset --hard '版本号'		    回退版本
git pull origin xxx				  从远程拉取代码并合并到本地分支
git push origin xxx				  提交远程
git commit -m '描述'			     提交到分支
git add . 					   	  提交到暂存区
git merge                         合并分支
```

#### http的请求报文

```
请求头
请求路径
请求方式
携带参数
```

#### http请求中get和post的区别

```
GET请求对服务器资源有缓存，POST请求无缓存。
GET请求适用于查询数据，POST请求适用于提交数据。
GET请求通过URL传递参数，POST请求通过请求体传递参数。
GET请求的参数是在URL中，POST请求的参数是在请求体中。
```

#### http请求的方式

```
HTTP请求的方法：
	HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
	HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法
						   options  put  delete  trace    connect  
```

#### http请求的状态码

```
http的状态码有很多
http状态码分为五类：
	1开头的代表信息状态码
	2开头的代表成功状态码
	3开头的代表重定向状态码
	4开头的代表客户端错误状态码
	5开头代表服务端错误状态码
常用状态码有：
	200：请求成功
	301：被请求的资源已经永久移动到新位置
	304：所请求的资源未修改（缓存）
	401 + 403：没有授权
	404：服务器无法根据客户端的请求找到资源
	500：服务器内部错误，无法完成请求
	503：由于超载或系统维护，服务器暂时无法处理客户端请求
301与303的区别：
	301转向(或叫301重定向，301跳转)是当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。

	303状态码：对于POST请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URI
```

#### 网络协议

```
http和https
```

#### http和https的区别

```
http：超文本传输协议，明文传输，信息不安全。用的是80端口
https：安全套接字超文本传输协议，增加了两个安全证书，信息安全。用的是443端口
http需要请求头 响应头 报文
```

#### 清除浮动方法

```
我们浮动元素后会带来：
1.如果父级未设置高度，父级盒子塌陷，
2. 上面元素浮动后，位于下面的元素会掉到上元素后面

解决方案：
1.给父级设置高度（缺点：无高的盒子无法用）
2.塌陷的父级盒子设置：overflow:hidden;（缺点：不可和定位属性同用）
3.掉上去的元素给：clear:both; 
```

#### position的属性和区别

```
fixed      固定定位
relative   相对定位
absolute   绝对定位

Fixed 固定定位基于浏览器窗口定位 
relative相对定位基于本身定位
absolute 绝对定位 ， 如果父级有定位属性，元素基于父级定位。
如果元素父级没有定位属性，
元素依次找它带定位属性的父级进行定位，
如所有父级都没有定位属性，则基于body定位
```

#### display的值有哪些

```
display: block;   设置为块元素
display: inline;  设置为行内元素
display: inline-block; 设置为行内块元素
display: none; 隐藏
```

#### 盒子的区别

```
17.块元素行内块级行内元素的区别？
行内元素：span  a  b  em  i  strong
宽高不起效,上下外间距不起效，可以一行并排显示

块元素：div  p  h1--h6 ul dl dt dd li  ol  form  option
宽高起效，上下外间距起效， 不可并排显示

行内块元素：input  img  button  select  textarea 
宽高起效，上下外间距起效，可以一行并排显示
```

#### 后台管理中的权限管理

```
权限管理是后台管理系统中非常重要的一部分，它通常包括用户角色的定义、角色权限的分配、权限的验证等功能。

一般来说，权限管理需要经过以下步骤实现：

1. 定义用户角色：将用户按照其职责和权限划分为不同的角色，如管理员、普通用户等。
2. 分配角色权限：为每个角色分配相应的权限，可以通过页面或接口等方式进行操作，如增删改查、导出、审核等。
3. 权限验证：在用户登录后通过路由守卫拦截验证用户所属的角色是否有对应的权限。
4. 权限控制：根据用户所属的角色和权限，通过router.addRoutes动态挂载路由，并根据权限控制其是否可操作。

需要注意的是，权限管理需要考虑安全性和易用性的平衡，要确保用户只能访问其具有权限的资源，同时也要让用户方便地进行操作。
```

#### 权限管理的权限分配

```
管理员分配给角色 角色的权限再分配给用户，不同用户登录会有不同的权限
```

#### 动态路由的实现

```
后台管理系统中的动态路由实现需要经历以下步骤：
1. 获取用户权限：在用户登录后，根据用户的权限信息，可以确定用户可以访问的路由。
2. 动态生成路由：根据用户的权限信息，动态生成路由表。只有用户有权限访问的路由才会被生成。
3. 路由守卫：在路由跳转时，使用路由守卫对用户的权限进行再次验证，确保用户只能访问其具有权限的页面。

需要注意的是，在实现动态路由时，需要考虑到系统的复杂性和安全性，要确保只有具有权限的用户才能访问相应的路由和菜单，同时也要保证系统的稳定性和易用性。
```

#### 权限按钮

```
后端返回权限，通过自定义指令动态生成按钮实现按钮鉴权
```

#### 如何获取动态路由

```
动态路由主要通过两个函数实现router.addRoute() 和 router.removeRoute()
```

#### 什么是路由

```
路由就是一种映射关系
```

#### 后台管理对token的处理

```
1.客户端使用用户名跟密码请求登录
2.服务端收到请求，去验证用户名与密码
3.验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端
4.客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage里
5.客户端每次向服务端请求资源的时候需要带着服务端签发的 Token
6.服务端收到请求，然后去验证客户端请求里面带着的Token，如果验证成功，就向客户端返回请求的数据

用户登录成功之后，我们会在全局钩子router.beforeEach中拦截路由，判断是否已获得token，在获得token之后我们就要去获取用户的基本信息了
```

#### vue双向绑定的原理

```
vue.js 采用数据劫持结合发布-订阅者模式,通过 Object.defineproperty 来劫持各个属性的setter和getter,在数据变动时发布消息给订阅者,触发相应的监听回调。
```

#### 虚拟DOM

https://www.cnblogs.com/gaosong-shuhong/p/9253959.html

```
虚拟DOM是什么:虚拟 DOM (VDOM)是真实 DOM 在内存中的表示,用JS对象的形式，表示DOM和DOM之间的嵌套关系.Vue在这个Virtual DOM 上实现了一个 diff 算法，当要重新渲染组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以使用虚拟DOM性能会比原生 DOM 快很多。
```

#### element表格拖拽

```
使用的 Vue.Draggable 拖拽插件
```

#### vue首次加载很慢，有什么优化的方法

```
Vue项目首次加载慢的原因可能有很多，例如大量的静态资源加载、网络延迟等。以下是一些常见的优化方法：

	路由懒加载：将路由按需加载可以减少首次加载的时间。可以使用Vue提供的异步组件和Webpack的code splitting功能来实现路由懒加载。
	图片懒加载：图片是静态资源中比较耗时的一种，可以使用Vue提供的vue-lazyload插件或者Intersection Observer API来实现图片懒加载。
	减少静态资源的大小：可以通过压缩、合并、缓存等方式来减小静态资源的大小，从而提高加载速度。
	使用CDN加速：将静态资源部署到CDN上可以加速资源的加载速度，减小服务器的负载并提高用户体验。
	优化Webpack配置：可以通过调整Webpack的配置来优化打包和加载速度，例如使用Tree shaking、code splitting、缓存等功能。
	服务器端渲染：使用服务器端渲染可以将首次加载的时间减少，并提高SEO效果。
	预渲染：对于静态页面可以使用预渲染的方式来提高首次加载速度，可以使用prerender-spa-plugin插件来实现。
	以上是一些常见的Vue项目首次加载慢的优化方法，可以根据实际情况进行选择和调整
```

#### 浏览器必须解决的兼容问题

```
在Web开发中，浏览器兼容性问题是一个必须要面对的问题，以下是一些常见的浏览器兼容性问题：

  CSS兼容性问题：不同浏览器对CSS的支持程度不同，可能导致同一份CSS在不同浏览器中呈现不一致。可以使用CSS Reset或Normalize.css来规避这些问题。
  不同浏览器的标签默认的margin和padding不同。
  JavaScript兼容性问题：不同浏览器对JavaScript的支持程度也不同，可能导致同一份JavaScript在不同浏览器中运行不一致。可以使用Babel或Polyfill等工具来解决这些问题。
  HTML兼容性问题：不同浏览器对HTML的支持程度也不同，可能导致同一份HTML在不同浏览器中呈现不一致。可以使用HTML5 Shiv或Modernizr等工具来解决这些问题。
  布局兼容性问题：不同浏览器的盒子模型计算方式不同，可能导致同一份布局在不同浏览器中呈现不一致。可以使用box-sizing: border-box来解决这些问题。
  响应式布局兼容性问题：不同浏览器的viewport解析方式不同，可能导致同一份响应式布局在不同浏览器中呈现不一致。可以使用meta标签来设置viewport，从而解决这些问题。
  以上是一些常见的浏览器兼容性问题，可以通过各种工具和技术来解决。在开发过程中，我们应该尽量遵循Web标准和规范，减少兼容性问题的出现。同时，可以使用一些现代化的工具和框架来简化开发，并提高浏览器兼容性。
```

#### js遇到的兼容问题

```
是要处理IE浏览器和非IE浏览器之间的兼容
1、获取滚动距离的兼容处理
	document.documentElement.scrollTop    非IE
    document.body.scrollTop   ==> 兼容IE  
2、阻止冒泡的兼容处理
	e.stopPropagation()	非IE   ||    e.cancelBubble 兼容IE
3、阻止默认行为
	preventDefault( ) 非IE  ||  	return  false  兼容IE
4、DOM2添加监听事件的兼容处理
	addEventListener 非IE || attachEvent  兼容IE
5、删除DOM2事件监听
	removeEventListener 非IE  || detachEvent  兼容IE
```

#### async和await的理解

```
async和await是ES2017引入的新特性，用于简化异步代码的编写。async函数是一个返回Promise对象的函数，它内部的异步操作将被自动转换为Promise对象。而await关键字只能在async函数内部使用，用于等待一个Promise对象的解析。当await关键字后面跟着一个Promise时，它会暂停async函数的执行，直到Promise对象的状态发生变化，然后将Promise对象的解析值作为await的返回值。使用async和await可以使异步代码看起来更像同步代码，提高代码的可读性和可维护性。但需要注意的是，在使用await时，需要将其放置在try-catch块中捕获错误，以防止程序崩溃。
```

#### 如何在vue中同时发送多个请求

```
通过axios.all

axios.all([
  axios.get('/api/endpoint1'),
  axios.get('/api/endpoint2'),
  axios.get('/api/endpoint3')
]).then(axios.spread((resp1, resp2, resp3) => {
  // 处理逻辑
}));
```

#### vue自定义指令

```
自定义指令：全局自定义指令
		  局部自定义指令
1、可以使用Vue.directive( dir_name , {} ) 来定义全局自定义指令
2、也可以使用 directives{ dir_name : {} } 来定义局部自定义指令
钩子函数 : 
    bind
        只调用一次, 当指令第一次绑定在元素上时.
        用来做一次性初始化操作.
    inserted
        当绑定元素已插入到父节点时调用.
        也就是说 必定存在父节点.
        但是 它 及它的父节点 未必存在文档中.
    update
        在包含该组件的VNode更新后调用该函数.
        可能在其子级更新前调用.
        指令的值可能已更改,可能未更改.最好通过判断新旧值来过滤掉不必要的操作.
基本语法
全局定义指令
 Vue.directive('xxx-xxx' , function( el , binding ) {
            el.style.backgroundColor = binding.value ;
        })
局部定义指令
directives:{   //自定义私有指令
             'fontweight':{
                  bind(el,binding){
                     el.style.fontWeight = binding.value;
                  },
                    },
              'color-swatch'(el, binding) {   //简写
                    el.style.backgroundColor = binding.value;
               }
         }
```

#### vue的渲染过程

```
模板编译：Vue会将模板编译成渲染函数。渲染函数的作用是将数据渲染到虚拟DOM中。

数据响应：Vue会将数据转换成响应式数据。当响应式数据发生变化时，Vue会自动更新视图。

虚拟DOM渲染：当数据发生变化时，Vue会重新渲染虚拟DOM。然后，Vue会通过比较新旧虚拟DOM的差异，计算出最小的DOM操作，然后将这些操作应用到真实的DOM中。

在Vue的渲染过程中，最重要的是虚拟DOM的概念。虚拟DOM是一个轻量级的JavaScript对象，它记录了DOM节点的信息。Vue使用虚拟DOM来提高渲染效率，因为在大多数情况下，重新渲染整个页面是不必要的。当数据发生变化时，Vue会重新渲染虚拟DOM，然后通过比较新旧虚拟DOM的差异，只更新必要的DOM节点，从而提高渲染效率。
```

#### vue-router是用来做什么的

```
vue-router是用来单页面跳转的
```

#### vue-router有几种模式

```
两种 hash模式和history模式
```

#### 怎样做js的异步编程

```
通过回调函数
通过promise
```

#### 深度优先遍历和广度优先遍历

```
一、指代不同
1、深度优先遍历：是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。
2、广度优先遍历：系统地展开并检查图中的所有节点，以找寻结果。
二、特点不同
1、深度优先遍历：所有的搜索算法从其最终的算法实现上来看，都可以划分成两个部分──控制结构和产生系统。正如前面所说的，搜索算法简而言之就是穷举所有可能情况并找到合适的答案，所以最基本的问题就是罗列出所有可能的情况，这其实就是一种产生式系统。
2、广度优先遍历：并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。
三、算法不同
1、深度优先遍历：把根节点压入栈中。每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱。找到所要找的元素时结束程序。如果遍历整个树还没有找到，结束程序。
2、广度优先遍历：把根节点放到队列的末尾。每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱。找到所要找的元素时结束程序。如果遍历整个树还没有找到，结束程序。
```

#### js的异步解决方案

```
回调函数
promise
async和await
```

#### 对vue的了解

```
Vue.js 是一款渐进式 JavaScript 框架，用于构建用户界面。它的核心库只关注视图层，易于上手，灵活且高效。Vue.js 可以轻松地与其他库或现有项目整合，也可用于开发单页面（SPA）应用程序和复杂的前端 Web 应用程序。Vue.js 采用了组件化的开发方式，使得应用程序的开发和维护更加容易。同时，Vue.js 还提供了很多工具和插件，如 Vue Router、Vuex 等，以便于开发者快速构建高质量的 Web 应用程序。
```

#### 什么是重绘和回流

```
重绘：
DOM树没有元素增加或删除，只是样式的改变(比如修改了颜色或背景色)，针对浏览器对某一元素进行单独的渲染，这个过程叫做重绘

回流：
当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。

区别：
回流比重绘更加的消耗性能，发生回流必定会重绘，重绘却不一定会导致回流。
```

#### 加快渲染速度可以从哪几个方面优化

```
加快渲染速度可以从以下几个方面进行优化：

1. 减少HTTP请求次数：通过合并CSS、JS文件，使用CSS Sprites或者Base64等技术，减少HTTP请求次数，从而减少页面加载时间。
2. 压缩资源文件：对CSS、JS、图片等资源文件进行压缩，可以减少文件大小，从而减少页面加载时间。可以使用一些工具，如Gzip等。
3. 使用CDN加速：使用CDN可以将资源文件分发到离用户最近的节点，从而加快资源加载速度，缩短页面渲染时间。
4. 优化CSS和JS：CSS和JS代码可以通过压缩、合并、去除注释等方式进行优化，减少文件大小，提高加载速度。
5. 异步加载：将不影响页面渲染的资源文件异步加载，可以提高页面渲染速度。比如，将JS文件放在页面底部，或者使用defer、async等方式异步加载JS文件。
6. 减少DOM操作：DOM操作是非常耗时的操作，应该尽可能减少DOM操作次数。比如，可以将多次的DOM操作合并成一次，或者使用文档碎片等技术。
7. 图片优化：对于图片，可以进行压缩、裁剪、缩放等操作，减少图片大小，提高加载速度。
8. 缓存优化：使用浏览器缓存可以减少资源请求次数，加快页面加载速度。可以通过设置HTTP缓存头，或者使用Web Storage等技术进行缓存优化。
```

#### 浏览器缓存

```
浏览器缓存主要是提高访问效率

强制缓存

就是比如说访问一个网站，第一次进入网站的时候静态资源（css/js/图片/icon）实际上是从服务器上下载的，但是当刷新的时候这些东西没有必要再从服务器上下载了，像这种浏览器会默认认为是强制缓存，所以当你第二次访问的时候，不会再去服务器下载了，同样会返回200状态码，但是这个资源他会从浏览器本地的缓存里边去取值

协商缓存

跟后台协商这个资源要不要进行缓存，如果需要的话，第一次返回状态码他是一个200的状态码，同时返回一个唯一表示，只要说这个资源在服务端没有变化，当你下次访问的时候，后台会对比这个标识，如果没有变动会返回一个304（缓存响应状态码）的状态，浏览器接收到304后，浏览器只需从本地把缓存资源拿出来就行了
```

#### 在vue中子组件为什么不能直接修改父组件传过来的值

```
在Vue中，子组件不能直接修改父组件传递过来的值。这是因为Vue使用了单向数据流的原则，即数据只能从父组件流向子组件，而子组件不能直接修改父组件中的数据。这是为了防止数据的混乱和组件之间的耦合度过高。

如果子组件需要修改父组件的数据，可以通过触发自定义事件的方式来告知父组件进行修改。父组件可以监听子组件触发的事件，并在相应的方法中修改数据。这样就可以实现子组件修改父组件数据的需求，同时也保持了单向数据流的原则。
```

#### css3特性

```
选择器：CSS3引入了更多的选择器，如属性选择器、伪类选择器、伪元素选择器等，能够更精确地选择页面中的元素。

圆角，rgb透明度

盒模型：CSS3中引入了box-sizing属性，可以更精确地控制盒模型的尺寸。

布局：CSS3中新增了flexbox布局和grid布局，可以更方便地实现复杂的页面布局。

动画和过渡：CSS3中引入了animation和transition属性，可以实现元素的动画效果和过渡效果，提高页面的交互性和用户体验。

响应式设计：CSS3中引入了媒体查询（media query）和响应式图片等技术，可以实现响应式设计，使页面能够适应不同大小的设备屏幕。

字体：CSS3中新增了@font-face规则，可以使用自定义字体，实现更丰富的页面设计效果。

渐变和阴影：CSS3中引入了渐变和阴影属性，可以实现更自然的渐变和阴影效果。

总的来说，CSS3的新特性为前端开发带来了更多的工具和技术，可以更方便地实现页面的设计和布局，提高页面的交互性和用户体验。
```



```
伪类选择器
nth-of-type()
nth-child()
```

#### flex布局

```
display：设置容器为flex或inline-flex，表示容器采用Flexbox布局。

flex-direction：设置容器中的子元素排列方向，可以是row（水平方向）、row-reverse（水平方向反向）、column（kɒləm）（垂直方向）或column-reverse（垂直方向反向）。

flex-wrap：设置子元素的换行方式，可以是nowrap（不换行）、wrap（换行，第一行在上方）或wrap-reverse（换行，第一行在下方）。

justify-content：设置子元素在主轴上的对齐方式，可以是flex-start（起点对齐）、flex-end（终点对齐）、center（居中对齐）、space-between（两端对齐，子元素之间的距离相等）或space-around（子元素两侧距离相等）

align-items：设置子元素在交叉轴上的对齐方式，可以是flex-start（起点对齐）、flex-end（终点对齐）、center（居中对齐）、baseline（基线对齐）或stretch（子元素拉伸充满容器）。

align-content：设置多行子元素在交叉轴上的对齐方式，可以是flex-start（起点对齐）、flex-end（终点对齐）、center（居中对齐）、space-between（两端对齐，子元素之间的距离相等）或space-around（子元素两侧距离相等）。

flex：设置子元素的伸缩性，可以是一个数字，表示子元素在分配剩余空间时所占比例。
```

#### HTML5的新特性

```
媒体查询
1. 新增绘画 canvas元素
2. 新增媒介回放 video 和 audio 元素
3. 新增本地离线存储 localStorage 和 sessionStorage
4. 新增语义化标签： header、footer、nav、section、article等
5. 新增表单控件，比如 calendar(日历)、date、time、email、url、search等
```

#### 路由守卫

```
路由守卫分为全局路由守卫，组件内路由守卫和路由独享守卫

全局路由守卫又分为前置路由守卫（beforEach）和后置路由守卫（afterEach）
路由独享守卫（beforEnter）
局部路由守卫有三个
beforeRouterEnter
beforeRouterUpdate
beforeRouterLeave
都有三个参数
//第一个参数to，包含的内容是切换后的路由对象，也就是跳转后的路由对象
//第二个参数from，包含的内容的是切换前的路由对象，也就是跳转前的路由对象
//第三个参数next()，是否往下执行，执行的话，如果不写的话路由就不会跳转，操作将会终止
```

#### 什么是ajax，他的原理是什么，优缺点是什么

```
Ajax是客户端向服务器端发送请求,而无需刷新页面的一种技术
Ajax的核心是XMLHttpRequest
优点：
	1.可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量
	2.避免用户不断刷新或者跳转页面，提高用户体验
缺点：
	1.对搜索引擎不友好
	2.要实现ajax下的前后退功能成本较大
	3.可能造成请求数的增加
	4.跨域问题限制
Ajax 的原理简单来说通过 XmlHttpRequest 对象来向服务器发异步请求，服务器接受到请求去数据库查询数据并获得数据，然后用 Js/jQ来操作 DOM 而更新页面。 这其中最关键的一步就是从服务器获得请求数据。
```

#### 原生ajax怎么使用

```
1.创建一个XMLHttpRequest异步对象
2.设置请求方式和请求地址
3.用send发送请求
4.监听状态变化
5.接收返回的数据并处理数据

// 代码实现
let xmlhttp = new XMLHttpRequest()
xmlhttp.open('请求方式','请求资源的地址')
xmlhttp.send(); 发送请求
xmlhttp.onreadystatechange=()=>{
	if(xmlhttp.readyState == 4){
		if(xmlhttp.status == 200 || xmlhttp.status == 304){
		console.log(xmlhttp.responseText)
		}
	}
}
```

#### axios和ajax的区别

```
基于Promise：Axios基于Promise实现，可以更好的处理异步请求；而Ajax通常使用回调函数处理异步请求。

支持取消请求：Axios支持取消请求，可以取消单个请求或者一组并发请求，而Ajax通常需要手动实现取消请求的功能。

自动转换数据：Axios可以自动将JSON数据转换为JavaScript对象，也可以自动将JavaScript对象转换为JSON数据；而Ajax需要手动实现数据的转换。

拦截器：Axios支持请求拦截器和响应拦截器，可以在请求或响应发送前或接收后进行一些操作，比如添加请求头、处理响应数据等；而Ajax通常需要手动实现拦截器的功能。

支持更多的请求方式：Axios支持更多的请求方式，包括GET、POST、PUT、DELETE等；而Ajax主要支持GET和POST请求。
```

#### h5实现支付功能

```
H5支付是指，前端在浏览器唤起微信app,支付成功后在回到浏览器。

前端发起请求，需要后台server支持，请求微信支付服务，返回前端微信支付的链接。我们的回调地址会以redirect_url 的形式拼的返回的链接后面，前端打开这个链接，就可以唤起微信支付。完成微信支付后，会回到回调地址。
```

#### 路由懒加载

```
使用component和import引入路径
```

#### vue中的内置组件

```
transition 为单个元素或组件提供动画过渡效果。
TransitionGroup 为列表中的多个元素或组件提供过渡效果。
keep-alive 缓存包裹在其中的动态切换组件。
component  主要作用为动态渲染组件。
Teleport 将其插槽内容渲染到 DOM 中的另一个位置。
Suspense 用于协调对组件树中嵌套的异步依赖的处理。
```

#### setTimeout和setInterval的区别

```
setTimeout只执行一次，setInterval可以执行多次
清除定时器clearTimeout clearInterval
```

#### jq常用选择器有哪些

```
基本选择器、层次选择器（组，父子级，后代祖先，兄弟）、伪类选择器、属性选择器
```

#### 路由传参

```
Params传参和query传参
区别：
1、params通过name传参，query通过path传参
2、query相当于get请求，参数会在地址栏显示，而params相当于post请求，参数不会在地址栏显示。
3、用params传参，F5强制刷新参数会被清空，用query，由于参数是用路径传参的所以F5强制刷新也不会被清空。
4、使用这两种方式传参的时候都可通过路由的name进行传参，所以在配置路由的时候需要加个name属性
```

#### router和route的区别

```
router是路由实例 包含路由中许多的关键对象和属性  路由实例上有Push( )  go( )  replace ( ) 等方法 和守卫钩子函数

route是路由源  每条路由都会有一个route对象，是一个局部的对象  有name path params query等属性
```

####  页面之间传值

```
父传子：
	父组件发送的形式是用v-bind绑定值到子组件身上。然后子组件用属性props接收。
子传父：
	子组件使用$emit(事件名,需要发送的值)触发自定义事件，父组件使用v-on监听（@事件名=获取值的方法）。
兄弟：
	A）、两个都要引入公共js->bus。首先是发送者，bus.$emit(名字，值)。然后是接受者,bus.$on("传过来的那个名字"，函数（值）)，这里要注意的是接受者的这个监听事件应该是放在钩子mounted事件内。同时注意this指向问题。（可用封装方法）
	B）、使用vuex和localStroage进行传值
	C）、借助父组件，让两个兄弟组件可以联动，子组件A将值传递给父组件，父组件再将值传递给子组件B
隔代组件：
	vuex、本地存储、事件车、$attrs/$listeners、provide / inject都可以实现。
```

#### 拉取支付

```
1.发起订单 api 请求，传递参数，商品 id 商品件数 拼成对象传递后端
2.后端处理返回五个参数，有订单号，有签名等，通过这些参数调用微信支付，里面有个paymand(随便写的)方法进行支付
3.有支付有成功和失败，成功了就再次请求后台，因为后台参数可能没改
4.然后发起的请求又成功了在返回列表页，或者继续购物
5.如果失败了就返回失败页面，失败页面有个继续支付，取消支付，返回支付
```



#### IOS端是如何适配的

```
IOS端的适配
	1、分析机型:整体上把现有的iOS屏幕分为两大类，非全面屏和全面屏
		非全面屏：（6、6s、7、8）和Plus系列（6 Plus、6s Plus、7 Plus、8 Plus)
		全面屏： iPhoneX  iPhoneXR  iPhone 11 等 
		屏幕尺寸总结，iPhone在逻辑像素共有四种，375x667，375x812，414x736，414x896
	2、安全区域
		非全面屏都是矩形，整个屏幕都是安全区域。
		全面屏受到大圆角、刘海以及底部的影响，UI图更需要考虑安全区域
		顶部44pt、 底部34pt	
	3、以iphone6为进行制作去适配其它机型，对iphoneX单独处理
```

#### webpack是什么

```
构建项目的工具，模块化打包机 或者 模块打包工具, 对应到前端开发来说，就是将很多的的 css文件，js文件，图片等“物品”，全都写进一个js文件，而不是在一个html页面通过script,link标签去引入多个静态资源.
```

#### webpack的作用

```
1)进行重新加载编译。实际就是将浏览器不认识的语法编译成浏览器认识的语法。比如less
编译成css，ES6 语法 转成 ES5等等。
2)减少io请求。通常我们在请求后，会返回一个html到浏览器。这时，我们如果打开控制台，就会发现在html页面通过script,link等标签引用的静态资源， 浏览器会再次发出请求去获取这些资源。但是webpack的打包，将所有的静态资源都合并好了，减少了io请求。
```

#### webpack的五个核心

```
1、entry
	入口（entry）指示webpack以哪个文件作为入口起点开始打包，分析构建内部依赖图。
2、output
	出口（output）指示webpack打包后的资源 bundles 输出到哪里，以及如何命名。
3、loader
	loader让webpack能够去处理那些非JavaScript资源css、img等，将它们处理成webpack能够识别的资源，可以理解成一个翻译过程（webpack自身只能理解js和json）。
4、plugins
	插件（plugins）可用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。
5、mode
	模式（mode）指示webpack使用相应模式的配置。
	开发模式（development）：配置比较简单，能让代码本地调试运行的环境。
	生产模式（production）：代码需要不断优化达到性能最好。能让代码优化上线运行的环境。
	都会自动启用一些插件，生产模式使用插件更多
```

#### webpack的打包优化

```
一、优化图片
	使用 url-loader 优化， 将小图片转化成base64压缩,防止小图片太多请求次数太多。
二、分离第三方包
	打包后的bundle.js文件夹较大，所以每次加载的时候，请求比较慢，所以有必要在打包时将第三方包分离出来。使用CommonsChunkPlugin 插件进行配置。
三、分离 css 文件并压缩 css 文件
	使用 extract-text-webpack-plugin 插件将css文件分离出来。为了使项目加载时候尽早优先加载css样式，也为了解决js文件体积过大的问题
四、压缩 js 文件
	使用 uglifyjs-webpack-plugin 将js压缩，减少打包后的 vendor.js , bundle.js 等js的文件大小
五、压缩Html
	为了减少打包后的文件体积，使性能更好，效率更高，提高加载速度，打包时有必要进行压缩。
	使用html-webpack-plugin 进行压缩
```

#### webpack的打包原理/ webpack工作原理/ webpack原理

```
一、webpack可以看做是模块打包机：
● 根据文件间的依赖关系对其进行静态分析，
● 然后将这些模块按指定规则生成静态资源，
● 当 webpack 处理程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。

 webpack会把js css image看作一个模块，用import/require引入
        找到入口文件，通过入口文件找到关联的依赖文件，把他们打包到一起
        把bundle文件，拆分成多个小的文件，异步按需加载所需要的文件
        如果一个被多个文件引用，打包时只会生成一个文件
        如果引用的文件没有调用，不会打包，如果引入的变量和方法没有调用也不会打包
        对于多个入口文件，加入引入了相同的代码，可以用插件把他抽离到公共文件中
```

#### uni-app监听事件滚动

```
使用 onPageScroll 监听
```

#### uni-app的生命周期

```
1.1 组件生命周期 ==》 就是vue的生命周期

	onload
	onshow
	onShareTimeline	分享朋友圈
	onShareAppMessage 分享到好友

1.2 页面生命周期 ==》pages目录中的.vue文件才有页面的生命周期
onLoad	监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参），参考示例		
onShow	监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面		
onReady	监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发		
onHide	监听页面隐藏
onUnload	监听页面卸载
onResize	监听窗口尺寸变化
onPullDownRefresh	监听用户下拉动作，一般用于下拉刷新，参考示例
onReachBottom	页面滚动到底部的事件（不是scroll-view滚到底），常用于下拉下一页数据。具体见下方注意事项
onTabItemTap	点击 tab 时触发，参数为Object，具体见下方注意事项
onShareAppMessage	用户点击右上角分享
onPageScroll	监听页面滚动，参数为Object
onShareTimeline	监听用户点击右上角转发到朋友圈
onAddToFavorites	监听用户点击右上角收藏
```

#### onLoad和onShow的区别

```
面试题：onLoad和onShow有什么区别？使用的场景
	onLoad是监听页面加载，onShow是监听页面显示，onLoad先执行，onShow后执行
	onLoad第一次进入本页面会执行一次（第一次进入A页面会执行一次onload、A页面进入B页面再回到了A页面，A页面onload就不在执行了），但是onShow是每次进入页面都会执行
```

#### uniapp可以用localStorage吗？

```
不行，uni-app中有自己的存储方式
```

#### uniapp的跳转

```
uni.navigateTo()  //保留当前页面，跳转到应用内的某个页面，使用uni.navigateBack可以返回到原页面
uni.switchTab()   //跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
```

#### 微信小程序能否使用cookie

```
微信小程序不可以使用cookie
```

#### 微信小程序登录

```
首先呢当用户点击登录按钮的时候呢 我们要调用他内置的那个api 就是uni.getUserProfile 然后获取到用户的信息 然后第二步呢我们要调用那个uni.login方法 会获取用户的code码 紧接着code码需要传给后端 来看下当前这个code码的这个用户有没有注册过 如果没有注册过 我们要发送一个请求 让用户去注册 然后注册的时候会传递一些比如openId，签名，原始数据，偏移量iv一些参数 那些参数具体我也记不住了 反正有六七个差不多吧 然后注册成功呢会返回那个token，获取用户信息。这就是微信登录的整个流程
（然后判断是否绑定手机号，没有绑定就弹出一个提示框，可以绑定也可以取消。
```

#### 微信小程序支付

```
首先用户选择商品规格后点击立即购买，这时判断用户是否登录，如果没登录就跳转到登录页，如果登录了就跳转到确认订单页面同时将当前订单商品的信息传递过去，然后用户点击确认订单时我们要判断用户是否有收货地址，如果没有就要去填写或者选择收货地址，如果有的话发起订单请求，传递用户uid,时间戳，商品信息，数量，备注，地址id参数，后端会在他的数据库里生成一个订单，生成订单以后会给前端传递一些参数 那我们这个参数最主要的目的就是 我们需要调用一个官方提供的一个api uni.requestPayment唤起微信支付，会有成功的回调和失败的回调，成功的话调到订单也的待发货栏，失败的话跳转到待支付栏。
```

```
微信支付流程
        1.创建订单
            获取到订单编号
        2.订单预支付
            将第一步获取到的 订单编号  传递给接口
            获取到支付需要使用的  必要参数
        3.调用小程序 API  发起微信支付
            调用 wx.requestPayment()方法,传入第二步的必要参数
            就能够判断支付成功与否了
        4.调用接口,判断定义是否真的支付完成了!

面试回答：

   1.创建订单
       请求创建订单的 API 接口：把（订单金额、收货地址、订单中包含的商品信息）发送到服务器
       服务器响应的结果：订单编号
   2.订单预支付
        请求订单预支付的 API 接口：把（订单编号）发送到服务器
        服务器响应的结果：订单预支付的参数对象，里面包含了订单支付相关的必要参数
   3.发起微信支付
        调用 uni.requestPayment() 这个 API，发起微信支付；把步骤 2 得到的 “订单预支付对象” 作为参数传递给 uni.requestPayment() 方法
        监听 uni.requestPayment() 这个 API 的 success，fail，complete 回调函数
```

#### 小程序的登录

```
wx.Togin 获取临时登录凭证code,获取code值后再加AppID，appsecret，同code一起传给后端，后端调用接口拿到seesion_key，openid并返回token 前端存储token
```

#### ts和js有什么不同

```
1、TypeScript 引入了 JavaScript 中没有的“类”概念
2、TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。
3、js没有重载概念，ts有可以重载
4、ts增加了接口interface、泛型、类、类的多态、继承等
5、ts对比js基础类型上，增加了 void/never/any/元组/枚举/以及一些高级类型
```

#### wabSocket

WebSocket 是一种在单个TCP连接上进行全双工通信的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据

```
// wabSocket构造函数，创建
let ws = new wabSocket('请求地址')
// 连接成功后的回调函数
ws.onopen = fucntion (params) {
	consloe.log('请求成功')
	ws.send('hello')
}
// 从服务器接受到信息时的回调函数
ws.onmessaage = fuction(e) {
	console.log('收到服务器响应',e.data)
}
// 连接关闭后的回调函数
ws.onclose = fuction(evt) {
	console.log('连接失败')
}
```

#### seo优化

```
1,控制首页链接数量
2,扁平化的目录层次
3,导航优化
4,网站的结构布局

网页代码优化：
设置title标题
在meta标签中进行一些描述
正文标题要用<h1>标签


设置title标题
通过meta标签通过keywords设置一些关键字
通过description进行网页描述
使用h5新增的语义化标签
vue中通过ssr服务端渲染
通过nuxt.js框架进行渲染
```

#### nuxt.js

```
基于 Vue.js 的服务端渲染的应用框架
应用场景：
做seo优化，使用服务端渲染
首屏页面加载速度慢，使用服务端渲染
```

#### tree.js 和 d3

```
用来做 3d 动画
```

#### julp

```
和webpack一样是个打包工具
```

#### 如何打电话

```
h5中的a标签
```

#### o2o

```
O2O这个简称的全称为Online To Offline
O2O模式的核心很简单，就是把线上的消费者带到现实的商店中去——在线支付购买线下的商品和服务，再到线下去享受服务

O2O和B2C、C2C的区别：

　　B2C、C2C是在线支付，购买的商品会塞到箱子里通过物流公司送到你手中;
　　O2O是在线支付，购买线下的商品、服务，再到线下去享受服务。
```

#### h5和安卓的交互

```
H5开发完成发给：
        安卓和ios交互：通过波瑞兹 调用安卓的方法  页面会嵌套在 webview(外波为哦) 里  安卓打包进行上线
```

#### 2x图和3x图

```
2x图和3x图是ui设计的，我们只需要使用的时候 按需引入就行了
```

#### vuex模块化需要注意什么

```
通过Modules将store分割成不同模块，每个模块拥有自己的state、mutations、actions、getters并且可以嵌套子模块。

不同mutations以及actions中函数的名字相同会出现函数被重复调用的情况
```

#### js判断数据类型的方法

```
typeof
includes
Array.isArray()
isNaN()
```

#### 当我们在浏览器的地址栏输入一个网址，然后回车，回车这一瞬间到看到页面到底发生了什么呢？

```
整个流程如下：

- 域名解析 -->
- 发起TCP的3次握手 -->
- 建立TCP连接后发起http请求 -->
- 服务器响应http请求，浏览器得到html代码 -->
- 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） -->
- 浏览器对页面进行渲染呈现给用户
- 断开链接，进行TCP的四次挥手

1.DNS解析，将域名地址解析为ip地址（当输入url回车之后）
	读取浏览器DNS缓存、读取系统DNS缓存、路由器DNS缓存、网络运营商DNS缓存
	递归搜索   blog.baidu.com
			.com域名下查DNS解析
			.baidu域名下查DNS解析
			.blog域名下查DNS解析
				出错了
2.（在跟服务器交互之前）TCP链接  TCP三次握手
		第一次握手：由浏览器发起，告诉服务器我要发送请求了
		第二次握手：由服务器发起，告诉浏览器我准备接收了，你赶紧发送吧。
		第三次握手：由浏览器发送，告诉服务器，我马上就发了。准备接收吧。

3.发送请求
	请求报文，HTTP协议的通信内容
4.接受响应
	响应报文
5.渲染页面
	-遇见HTML标记，浏览器会调用HTML解析器，解析成Token标记（对象上的属性名和属性值）并构成DOM树
	-遇见style/link标记，浏览器调用css解析器，处理css标记并构建cssDOM树
	-遇到script标记，调用javascript解析器，处理script代码（绑定事件，修改dom树/cssdom树）
	-将dom树和cssdom树合并成一个（render）渲染树
	-根据渲染树来计算布局，计算每个节点的几何信息（布局）
    -将各个节点颜色绘制到屏幕上（渲染）

	注意：

		这个5个步骤不一定按照顺序执行，如果dom树或cssdom树被修改了，可能会执行多次布局和渲染，往往实际页面中，这些步骤都会执行多次的。

6.断开链接 TCP的四次挥手
	第一次挥手：由浏览器发起的，发送给服务器，我东西发送完了（请求报文），你准备关闭吧。
	第二次挥手：由服务器发起的，告诉浏览器，我东西接受完了（请求报文），我准备关闭了，你也准备吧。
	第三次挥手：由服务器发起，告诉浏览器，我东西发送完了（响应报文），你准备关闭吧。
	第四次挥手：由浏览器发起，告诉服务器，我东西接受完了（响应报文），我准备关闭了，你也准备吧
```

#### 前端捕捉错误

```
正常代码就try catch捕捉就可以，但是只限于同步代码
promise异步代码的话在promise catch里边捕获，或者可以把promise放到async和await里边把他编程一个类似于同步函数的一个形式，里边直接使用try catch进行diamante捕获
```

####  src和href的区别

```
src和href 都是用来引入外部资源的属性，就比如说像图片、视频、CSS文件、js文件等。
href超文本引用，用于建立文档与资源的联系，常用的有：link、a标签等
src将所指向的资源下载并应用到当前页面，常见的有script、img等。
```

#### 单页面应用和多页面应用的优缺点

```
单页面优点
用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小
单页面缺点
不利于seo优化
页面复杂度提高很多
```

#### vue3获取组件的方法

```
vue3提供了一个getCurrentInstance方法用来获取当前组件的实例
```

#### rem和em的区别

```
em是相对于父元素的字体大小来变化的，跟rem相比em有局限性，因为em只能相对父级文字大小变化，而rem是相对于根元素大小变化的。
rem是等比缩放
```

#### pc端屏幕适配的宽度

```
800	 1024	 1280	 1336	 1440	 1600	 1680	 1920
```

#### 什么是栅格布局

```
grid布局被称为栅格布局，也被称为网格布局，他可以将网页划分为许多个方格，我们可以在网格中填充自己的内容。
```

#### 什么是迭代器

```
在我印象中我记得for of循环就只循环拥有迭代器的属性 然后迭代的定义的话是：从一个数据集合中按照一定的顺序，不断取出数据的过程称为迭代 
对象拥有symbol.cat那么就是可迭代的
```

#### 混入

```
混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项
```

#### JSON序列化

```
是一种存储和交换文本信息的语法
JSON.parse()
JSON.stringify()
```

#### vue父子组件生命周期的执行顺序

```
父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted->父beforeUpdate->子beforeUpdate->子updated->父updated->父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

父3子4父2子2父2子2父1
```

#### vue3为什么使用proxy

```
1.proxy可以代理整个对象，defineproperty只代理对象上的某个属性
2.proxy对代理对象的监听更加丰富
3.proxy代理对象会生成新的对象，不会修改被代理对象本身
4.proxy不兼容ie浏览器
```

#### 浏览器端渲染(CSR)和服务端渲染(SSR)

```
浏览器端渲染:页面上的内容是我们加载的js文件渲染出来的，js文件运行在浏览器上面，服务端只返回一个html模板
服务端渲染：页面上的内容是通过服务端渲染生成的，浏览器直接显示服务端返回的html就可以了
```

#### 浏览器渲染的顺序

```
1.构建dom树
2.构建css树
3.构建渲染树
4.节点布局
5.页面渲染
```

####     uni-app有没有做过分包

分包需要配置pages.json文件

```
优化小程序的下载和启动速度
小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示
```

#### 上传文件时请求头是什么？

```
涉及到文件上传时接口需要配置请求头：headers: { ‘Content-Type’: ‘multipart/form-data’ }
```

#### 下载文件时的请求头是什么

```
( "Content-Type: application/vnd.ms-excel">
```

#### 数据变了视图没变

```
原因：vue重写了数组的方法，如果直接改变了数组的长度，响应式可能会失效，这种情况应该赋值一个空数组。
先考虑响应式再考虑$set和$delete
通过$set添加属性或者通过$delete删除属性

student: { name: '张三' }
this.$set(this.student, 'age', 15)

原因:
因为vue初始化实例会进行数据绑定,通过Object.defineproperty来劫持属性的setter和getter，所以属性必须在 data中存在时才是响应的。如果要给对象添加新的属性，就不是响应式的，就需要通过$set去实现响应式
```

#### uniapp图片上传

```
uni.chooseImage：从本地相册选择图片或使用相机拍照。
属性：
count：最多可以选择的图片张数，默认9
sizeType：original 原图，compressed 压缩图，默认二者都有
sourceType：album 从相册选图，camera 使用相机
success：成功则返回图片的本地文件路径列表 tempFilePaths
```

#### js开启严格模式

```
"use strict"是JavaScript中一个非常好的特性
```

#### 什么是面向对象

```
将程序中的数据和行为封装成对象 通过对象之间的交互实现程序的功能， 他能够提高程序的模块化程度 方便我们后期维护和重用和修改
三大基本特征，即封装、继承和多态

可以抓住关键字:说创建对象的方式: 字面量 构造函数方式 工厂函数方式
```

#### 事件循环

```
js是单线程的语言，js把任务分为同步任务和异步任务，js会把所有的主线程任务放在主线程上去执行，把所有的异步任务放在事件循环中去执行，当所有的同步任务执行完之后，再去事件队列中看看有没有异步任务，有就执行异步任务，在ES6中由于增加了promise，所以在异步任务中又分为宏任务和微任务，宏任务有宏任务：setTimeout、setInterval，微任务有promise.then和process.nextTick( ),先执行同步再执行异步，异步遇到微任务，先执行微任务，执行完后如果没有微任务，就执行下一个宏任务，如果有微任务，就按顺序一个一个执行微任务。

2. js代码执行流程：同步执行完==》事件循环
	同步的任务都执行完了，才会执行事件循环的内容
	进入事件循环：请求、定时器、事件....
3. 事件循环中包含：【微任务、宏任务】
微任务：promise.then
宏任务：setTimeout和setInterval

要执行宏任务的前提是清空了所有的微任务

流程：同步==》事件循环【微任务和宏任务】==》微任务==》宏任务=》微任务...
先执行同步再执行异步，异步遇到微任务，先执行微任务，执行完后如果没有微任务，就执行下一个宏任务，如果有微任务，就按顺序一个一个执行微任务
```

#### 什么是BFC

```
BFC：块级格式化上下文。
W3C官方解释为：BFC它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，Block Formatting Context提供了一个环境，HTML在这个环境中按照一定的规则进行布局。
简单来说就是，BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。那么怎么使用BFC呢，BFC可以看做是一个CSS元素属性

怎么开启BFC：
overflow: hidden
display: inline-block
position: absolute
position: fixed
display: table-cell
display: flex
```

#### 打包上线流程

```
开研讨会 明确功能 分配模块 进行开发 打包测试 上线

1.运维打包 测试拉取项目通过后，通过禅道给前端显示bug让我们修改，部署服务器也是运维操作。
2.没有运维:完成功能后测试通过 直接打包发给后端，后端整体上线，(如果我们上线，直接run buid打句后将文件拖拽到服务器文件夹下边)
```

#### 打包上线

```
1、在项目文件夹下运行npm run build
2、我们会发现在原来的项目文件夹中多出了一个dist文件夹，这个文件夹就是我们要放到线上的内容
我们把这个dist文件夹给到后端的工作人员，后端的工作人员，后端的工作人员就会把这个文件挂载到后端服务器上
现在我们把dist文件夹里的内容放在指定文件夹中
```

#### token过期怎么处理

```
我们的项目接口中设定的 Token 有效期是七天，超过有效期服务端会返回 401 表示 Token 无效或过期了
在axios的拦截器中加入token刷新逻辑
当用户token过期时，去向服务器请求新的 token
把旧的token替换为新的token
然后继续用户当前的请求
```

### 栈和堆

```
栈：放基本数据类型
堆：放复合数据类型
```

#### push和replace的区别

```
push（/path）里面的path会进入路由栈
replace不会，但是它里面的path会替换掉路由栈里最后一个路由。

replace和push都能实现跳转的效果，但是区别在于：replace不会向history插入记录，而push会向history插入
```

#### 插槽的用途

```
1、显示标签，在组件内部通过【<slot></slot>】进行接收；
2、命名插槽，增加插槽的灵活性；
3、带参数的插槽，将插槽中的数据使用组件内部的数据。
```

#### 回文

```
回文字符串：即字符串从前往后读和从后往前读字符顺序是一致的。

let palindRome = (str) => {
    if (!str || (str && typeof str !== 'string')) {
        return
    }
    return str === str.split('').reverse().reducer((total, cur) => total+cur)
}
```

#### vue脚手架

```
Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统
基于 webpack 构建，并带有合理的默认配置；
可以通过项目内的配置文件进行配置；
可以通过插件进行扩展。
```

#### app发布

```
申请软件著作权
申请电子市场账号（小米，华为，滕讯）
上传ios市场需要花钱（个人软件大概99元，公司大概299元）
然后上传app（需要app应用信息，应用名称，应用分类，logo，应用截图，上传备案截图）
然后上传安装包
然后等待审核（通过：上架成功，不通过：上架失败，按要求修改）
```

#### ios支付

```
初始化验证（验证两次，看看是否能发起支付）
请求ios内购的一些信息
刚开始是沙箱支付，然后真正的支付
```

#### 热更新

```
对比版本号不同，强制用户更新
```

#### 300毫米延迟

```
firstclick.js

FastClick是专门未解决移动端浏览器300ms点击延迟和点击穿透问题所开发的一个轻量级的库。FastClick实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即发出模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。
```

#### 安卓与js（前端）的交互

```
使用的WebView
```

#### script 标签中 defer 和async 的区别

```
efer 和 async有一个共同点：下载此类脚本都不会阻止页面呈现（异步加载），区别在于：

1.async 执行与文档顺序无关，先加载哪个就先执行哪个；defer会按照文档中的顺序执行
2.async 脚本加载完成后立即执行，可以在DOM尚未完全下载完成就加载和执行；而defer脚本需要等到文档所有元素解析完成之后才执行
```

#### $nextTick

```
vue的dom更新是异步的，当数据改变后dom不会立即更新，如果在数据更新之后想拿到更新之后dom的内容，这个时候需要使用$nextTick。
在created中获得数据操作，在$nextTick操作dom
```

#### $set和$get

```
$set 方法用于添加响应式对象的属性，并确保这个新属性也是响应式的
$get 方法用于获取响应式对象的属性值，它可以直接访问对象的属性并返回属性值
```

